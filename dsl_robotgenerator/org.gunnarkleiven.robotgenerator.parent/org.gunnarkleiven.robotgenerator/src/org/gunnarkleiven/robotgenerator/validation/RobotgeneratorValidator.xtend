/*
 * generated by Xtext 2.25.0
 */
package org.gunnarkleiven.robotgenerator.validation

import org.gunnarkleiven.robotgenerator.robotgenerator.Model
import org.gunnarkleiven.robotgenerator.robotgenerator.Command
import org.gunnarkleiven.robotgenerator.robotgenerator.RobotgeneratorPackage
import org.eclipse.xtext.validation.Check
import org.gunnarkleiven.robotgenerator.robotgenerator.RobotType


/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class RobotgeneratorValidator extends AbstractRobotgeneratorValidator {
	
	protected static val ISSUE_CODE_PREFIX = "org.example.robotgenerator"
	
	public static val INVALID_ROBOT_TYPE = ISSUE_CODE_PREFIX + "InvalidRobotType"
	public static val ILLEGAL_ROBOT_NAME = ISSUE_CODE_PREFIX + "IllegalRobotName"
	public static val DUPLICATE_ROBOT_NAMES = ISSUE_CODE_PREFIX + "DuplicateRobotNames"
	
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					RobotgeneratorPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}

	@Check
	def checkValidRobotType(Command command) {
		var isEnum = false;
		// Iterate through all the available Enums, and check if the command value is
		// one of them
		for (RobotType t : RobotType.VALUES) {
			if (command.robotType.equals(t)) {
				isEnum = true;
			}
		}
		if(!isEnum) {
			error("Invalid robot type: '" + command.robotType.getName + "'",
				RobotgeneratorPackage.eINSTANCE.command_RobotType,
				INVALID_ROBOT_TYPE,
				command.robotType.getName
			);
		}
	}

	@Check
	def checkLegalRobotName(Command command) {
		val illegalNames = newArrayList("moose", "mavic2pro")
		val commandName = command.robotName.value
		if (illegalNames.contains(commandName)) {
			error("Protected robot name '" + commandName + "'",
				RobotgeneratorPackage.eINSTANCE.command_RobotName,
				ILLEGAL_ROBOT_NAME,
				command.robotName.value
			)
		}
	}
	
//	@Check
//	def checkDuplicateRobotNames(Model model) {
//		val usedRobotNames = newHashSet()
//		for (Command c : model.commands) {
//			val currentName = c.robotName.value
////			print(currentName)
//			if (usedRobotNames.contains(currentName)) {
//				error("Duplicate robot name: '" + currentName + "'",
//					RobotgeneratorPackage.eINSTANCE.command_RobotName,
//					DUPLICATE_ROBOT_NAMES,
//					currentName					
//				)
//				return
//			}
//			usedRobotNames.add(currentName)
//		}
//	}
//	
//	def private void checkNoDuplicateValue() {
//		val hashSet = newHashSet
//		RobotgeneratorPackage.Literals.		
//		
//		for ()	
//	}
	
}
